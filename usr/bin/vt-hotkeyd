#!/usr/bin/env python3
"""
vt-hotkeyd: VT switch helper for Cage sessions.

Listens for Super+F<N> on a chosen keyboard device and calls
`loginctl activate <N>` so the compositor does not need to expose VT
switching shortcuts. Intended to be launched manually from another TTY.
"""
import argparse
import errno
import glob
import os
import select
import struct
import subprocess
import sys

EVENT_STRUCT = struct.Struct("llHHi")  # timeval(sec,usec), type, code, value
EVENT_SIZE = EVENT_STRUCT.size

EV_KEY = 0x01

KEY_LEFTMETA = 125
KEY_RIGHTMETA = 126
KEY_LEFTCTRL = 29  # optional guard
KEY_RIGHTCTRL = 97

META_KEYS = {KEY_LEFTMETA, KEY_RIGHTMETA}
CTRL_KEYS = {KEY_LEFTCTRL, KEY_RIGHTCTRL}

FKEY_TO_VT = {
    59: 1,   # KEY_F1
    60: 2,   # KEY_F2
    61: 3,   # KEY_F3
    62: 4,   # KEY_F4
    63: 5,   # KEY_F5
    64: 6,   # KEY_F6
    65: 7,   # KEY_F7
    66: 8,   # KEY_F8
    67: 9,   # KEY_F9
    68: 10,  # KEY_F10
    87: 11,  # KEY_F11
    88: 12,  # KEY_F12
}


def default_device():
    candidates = sorted(glob.glob("/dev/input/by-path/*-event-kbd"))
    if candidates:
        return candidates[0]
    candidates = sorted(glob.glob("/dev/input/event*"))
    for path in candidates:
        if os.path.basename(path).isdigit():
            # Skip bare numeric event names; prefer by-path entries.
            continue
        return path
    return None


def open_device(path):
    try:
        fd = os.open(path, os.O_RDONLY | os.O_NONBLOCK)
    except OSError as exc:
        if exc.errno in (errno.EACCES, errno.EPERM):
            sys.stderr.write(f"vt-hotkeyd: cannot open {path}: permission denied\n")
        else:
            sys.stderr.write(f"vt-hotkeyd: cannot open {path}: {exc}\n")
        return None
    return fd


def run_loop(fd, require_ctrl):
    poller = select.poll()
    poller.register(fd, select.POLLIN | select.POLLPRI)
    meta_down = set()
    ctrl_down = set()

    while True:
        for _fd, mask in poller.poll():
            if mask & (select.POLLERR | select.POLLHUP):
                raise RuntimeError("device disconnected")
            try:
                data = os.read(fd, EVENT_SIZE * 16)
            except BlockingIOError:
                continue
            if not data:
                raise RuntimeError("no data from device")
            for offset in range(0, len(data), EVENT_SIZE):
                chunk = data[offset: offset + EVENT_SIZE]
                if len(chunk) < EVENT_SIZE:
                    continue
                _, _, etype, code, value = EVENT_STRUCT.unpack(chunk)
                if etype != EV_KEY:
                    continue
                if code in META_KEYS:
                    if value == 1:
                        meta_down.add(code)
                    elif value == 0:
                        meta_down.discard(code)
                    continue
                if code in CTRL_KEYS:
                    if value == 1:
                        ctrl_down.add(code)
                    elif value == 0:
                        ctrl_down.discard(code)
                    continue
                if value != 1:  # only react on key press
                    continue
                if code not in FKEY_TO_VT:
                    continue
                if not meta_down:
                    continue
                if require_ctrl and not ctrl_down:
                    continue
                vt = FKEY_TO_VT[code]
                activate_vt(vt)


def activate_vt(vt):
    try:
        subprocess.run(["loginctl", "activate", str(vt)], check=True)
    except subprocess.CalledProcessError as exc:
        sys.stderr.write(f"vt-hotkeyd: loginctl activate {vt} failed: {exc}\n")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Switch VTs on Super+Fx even when the compositor grabs the keyboard."
    )
    parser.add_argument(
        "--device",
        help="evdev device path (default: first /dev/input/by-path/*-event-kbd)",
    )
    parser.add_argument(
        "--require-ctrl",
        action="store_true",
        help="also require Ctrl to be held with Super+Fx",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    device = args.device or default_device()
    if not device:
        sys.stderr.write("vt-hotkeyd: could not locate a keyboard device; use --device\n")
        return 1
    fd = open_device(device)
    if fd is None:
        return 1
    try:
        sys.stderr.write(f"vt-hotkeyd: listening on {device}\n")
        sys.stderr.write("vt-hotkeyd: press Super+F1..F12 to switch VTs\n")
        run_loop(fd, require_ctrl=args.require_ctrl)
    except KeyboardInterrupt:
        sys.stderr.write("vt-hotkeyd: interrupted, exiting\n")
    except RuntimeError as exc:
        sys.stderr.write(f"vt-hotkeyd: {exc}\n")
        return 1
    finally:
        os.close(fd)
    return 0


if __name__ == "__main__":
    sys.exit(main())
